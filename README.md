
# Милые пёсики
У нас есть программа для загрузки [картинок собак](https://dog.ceo/dog-api/documentation). Для этой программы уже написан тест.  
На вход подается порода собаки. Функция находит одну случайную картинку этой собаки и загружает её на [Я.Диск](https://yandex.ru/dev/disk/poligon/).
Если у породы есть подпороды, то для каждой подпороды загружается по одной картинки.
Например, для doberman будет одна картинка, а для spaniel 7 картинок по одной на каждую подпороду.

# Задание:
Нужно перечислить 10 основных проблем в коде.  
Все найденные проблемы нужно отранжировать по критичности.

# Задание со звёздочкой:
Переписать код так, как Вы считаете нужным, исправив все проблемы.





Правки http-клиента:
1. Токен авторизации передается каждый раз вручную. Я вынес токен как отдельную константу наружу,
   а в класс аплоадера передаю в качестве параметра конструктора, при этом дав ему значение по умолчанию. 
   Это позволяет создавать экземпляр класса аплоадера как без указания токена авторизации, так и с указанием токена,
   если предполагается использование аплоадера от имени разных пользователей

2. Хедеры в аплоадере используются одни и те же - Content-Type, Accept, Authorization.
   Вынес этот набор как приватное поле, которое вычисляется во время инициализации.

3. Базовый урл для YaUploader имеет смысл вынести отдельно, а не указывать в каждом вызове.
   Можно оставить его в YaUploader'e как статическое поле класса, но я решил вынести в отдельный класс с базовыми урлами.
   В условиях, когда используется много http-клиентов, может возникать потребность иметь все базовые урлы в одном файле. 
   Также, если используется множество тестовых окружений,
   использование отдельного класса с урлами облегчит переключение между окружениями в тестах.
   
   Аналогично базовый урл dog-ceo.

4. Методы YaUploader не возвращают значение. Добавил возврат response.json()

5. Яндексовый клиент унес в отдельный файл. Собачий клиент выделил в отдельный класс и тоже унес.
   Выделил для хттп клиентов отдельную директорию network



Правки теста:
1. Тест не использует блага YaUploader'а, определяя запросы каждый раз на месте. Исправил. 

2. Убрал из теста бесполезный assert True. Вреда не несет, но и пользы в нем нет.

3. Убрал слово proverka из имени теста. Смотрится чужеродно, смысла не несет, т к префикс test в имени имеет тот же смысл.

3. Выделил "response['_embedded']['items']" как отдельную переменную, чтобы улучшить читабельность кода

4. Убрал лишний вызов get_sub_breeds(breed) - достаточно это сделать один раз и пользоваться результатом.

5. Убрал random.choice из списка пород с подпородами.
   Не стоит вносить элемент случайности в тест, т к тест должен быть предсказуем и выполнять понятный сценарий при каждом запуске.

6. Разделил тест на два: один проверяет породу без суб-пород, второй - породу с суб-породами.
   Считаю ветвление в тесте плохой практикой - по возможности стоит оформлять для разных веток отдельные кейсы,
   если это не влечет больших затрат на повторное прохождение сетапа теста. В данном случае этого не происходит.
   Но в целом это вопрос дискусионный, зависит от того, что принято в компании.

7. Переназвал фукцию u в upload_photos
8. Добавил функции upload_photos (бывшая u) параметр папки для загрузки
  
9. Все тесты пишут в одну папку test_folder и не очищают ее. Это приводит к тому, что результаты предыдущих тестов ломают следующие.
   Также наборы параметров мешают друг другу. 
   Написал менеджер тестовых папок, который генерит уникальные названия, и запоминает те, что уже создал. 
   Написал фикстуру, которая в конце тестовой сессии удаляет все созданные папки, чтобы не засорять диск.

10. После заливки фоток get_resource получает актуальное состояние не сразу.
    Нужно написать ожидалку, которая будет делать несколько ретраев в попытке дождаться желаемого результата.
    Либо просто сделать слип на 3-5 секунд, но это плохая практика


Есть еще несколько потенциальных возможностей для улучшения, которыми я не стал заниматься в рамках этого задания:
1. Делать проверку списка через for-each - не самая лучшая практика. Встретив ошибку на середине списка, тест падает и мы теряем информацию о всех последующих проверках.
   Нужно делать кастомную функцию, которая проходит по всем элементам списка и накапливает ошибки и в конце выдает полный список. 
   Не стал этим заниматься в рамках этого задания.
2. Имеет смысл парсить ответы хттп-запросов в датаклассы и работать с ними как с объектами, а не словарями.
3. Имеет смысл добавить логирование хттп-запросов, чтобы было ясно, какой запрос был отправлен, и какой был получен ответ.
   Но делать это надо не точечно для каждого запроса, а написать универсальный хттп-клиент, который будет это делать для всех запросов
4. Также для повышения читабельности теста надо добавить степы, например аллюровские. 